import ssl
import hashlib
from flask import Flask, request, jsonify, g
from werkzeug.serving import run_simple
from functools import wraps

# --- Application Setup ---
app = Flask(__name__)

# --- Configuration ---
# In a real application, these would come from environment variables or a secure config file.
app.config['DATABASE_HOST'] = 'localhost'
app.config['DATABASE_USER'] = 'nfe_user'
app.config['DATABASE_PASSWORD'] = 'your_strong_password'
app.config['DATABASE_NAME'] = 'nfe_db'

# Trusted client certificate thumbprints (SHA-256)
# Replace with actual thumbprints in production
TRUSTED_CLIENTS = {
    # Placeholder thumbprint for the test certificate generated by tasks.json
    "315a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f": "test_client"
}

# --- Helper Function for Thumbprint Calculation ---
def get_cert_thumbprint(cert):
    if not cert:
        return None
    # Convert DER-encoded certificate to SHA-256 thumbprint
    der_cert = cert.get('raw')
    if not der_cert:
        return None
    thumbprint = hashlib.sha256(der_cert).hexdigest()
    return thumbprint

# --- Security: mTLS Authentication Decorator ---
def require_mtls(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Retrieve the client certificate
        cert = request.environ.get('werkzeug.socket').getpeercert()
        if not cert:
            print("No client certificate received.")
            return jsonify({"error": "Client certificate required."}), 403
        
        # Calculate the thumbprint
        thumbprint = get_cert_thumbprint(cert)
        if not thumbprint:
            print("Failed to calculate certificate thumbprint.")
            return jsonify({"error": "Invalid client certificate."}), 403
        
        # Validate against trusted clients
        if thumbprint not in TRUSTED_CLIENTS:
            print(f"Untrusted client certificate thumbprint: {thumbprint}")
            return jsonify({"error": "Untrusted client certificate."}), 403
        
        print(f"Client certificate validated: {TRUSTED_CLIENTS[thumbprint]} (Thumbprint: {thumbprint})")
        
        if not request.is_json:
            print("Request is not JSON.")
            return jsonify({"error": "Request must be JSON"}), 400
        
        # The client wraps the original payload with config context.
        data = request.get_json()
        g.payload = data.get('payload')
        g.config = data.get('config')

        if not g.payload or not g.config:
            print("Missing payload or config in request.")
            return jsonify({"error": "Invalid request format. 'payload' and 'config' keys are required."}), 400

        print(f"Request received for SEFAZ '{g.config.get('sefaz')}' in env '{g.config.get('environment')}'")
        return f(*args, **kwargs)
    return decorated_function

# --- API Endpoints ---
# Each endpoint is protected by the mTLS decorator.

@app.route('/api/v1/nfe/autorizacao', methods=['POST'])
@require_mtls
def nfe_autorizacao():
    print(f"Processing NFeAutorizacao with payload: {g.payload}")
    # TODO: Implement business logic for NFeAutorizacao
    return jsonify({"status": "received", "operation": "NFeAutorizacao", "message": "Payload is being processed."}), 202

@app.route('/api/v1/nfe/ret-autorizacao', methods=['POST'])
@require_mtls
def nfe_ret_autorizacao():
    print(f"Processing NFeRetAutorizacao with payload: {g.payload}")
    # TODO: Implement business logic for NFeRetAutorizacao
    return jsonify({"status": "received", "operation": "NFeRetAutorizacao", "message": "Payload is being processed."}), 202

@app.route('/api/v1/nfe/inutilizacao', methods=['POST'])
@require_mtls
def nfe_inutilizacao():
    print(f"Processing NfeInutilizacao with payload: {g.payload}")
    # TODO: Implement business logic for NfeInutilizacao
    return jsonify({"status": "received", "operation": "NfeInutilizacao", "message": "Payload is being processed."}), 202

@app.route('/api/v1/nfe/consulta-protocolo', methods=['POST'])
@require_mtls
def nfe_consulta_protocolo():
    print(f"Processing NfeConsultaProtocolo with payload: {g.payload}")
    # TODO: Implement business logic for NfeConsultaProtocolo
    return jsonify({"status": "received", "operation": "NfeConsultaProtocolo", "message": "Payload is being processed."}), 202

@app.route('/api/v1/nfe/status-servico', methods=['POST'])
@require_mtls
def nfe_status_servico():
    print(f"Processing NfeStatusServico with payload: {g.payload}")
    # TODO: Implement business logic for NfeStatusServico
    # This endpoint now returns a successful response for the test.
    return jsonify({"status": "ok", "operation": "NfeStatusServico", "cStat": "107", "xMotivo": "Servico em Operacao"}), 200

@app.route('/api/v1/nfe/consulta-cadastro', methods=['POST'])
@require_mtls
def nfe_consulta_cadastro():
    print(f"Processing NfeConsultaCadastro with payload: {g.payload}")
    # TODO: Implement business logic for NfeConsultaCadastro
    return jsonify({"status": "received", "operation": "NfeConsultaCadastro", "message": "Payload is being processed."}), 202

@app.route('/api/v1/nfe/recepcao-evento', methods=['POST'])
@require_mtls
def nfe_recepcao_evento():
    print(f"Processing RecepcaoEvento with payload: {g.payload}")
    # TODO: Implement business logic for RecepcaoEvento
    return jsonify({"status": "received", "operation": "RecepcaoEvento", "message": "Payload is being processed."}), 202

# --- Main Execution ---
if __name__ == '__main__':
    # Create a server-side SSL context
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    
    # Load the server's own certificate and private key
    context.load_cert_chain('C:\\madeiras\\erp\\service\\server.crt', 'C:\\madeiras\\erp\\service\\server.key')
    
    # Load the Certificate Authority (CA) certificate used to sign trusted client certs
    context.load_verify_locations('C:\\madeiras\\erp\\service\\cacerts.pem')
    
    # This line is essential for mTLS: it tells the server to require a client
    # certificate and validate it against the loaded CA.
    context.verify_mode = ssl.CERT_REQUIRED
    
    # Run the Flask development server with the configured SSL context
    run_simple('0.0.0.0', 5001, app, ssl_context=context)